# identification

For this challenge, we're provided with a `proclamation.dat` file. We can easily identify that this is a bootloader and the `strings` are teasing us:

```console
$ file proclamation.dat
proclamation.dat: DOS/MBR boot sector
$ strings proclamation.dat
you're on a good way.
```

Ok, time to load this bootloader in a disassembler to look at it. This is a bootloader, we know that it should be mapped at `0x7c00` and has a length of `0x200`. In `Ghidra`, you go in `Window > Memory Map` and remap the map you see to start and end at those addresses.

![Alt text](imgs/ghidra_memory_map.png?raw=true "Properly mapped bootloader")

We can start the bootloader in `qemu` by using the following command and see that we won't get anything, nor can interact (at least visibly) with this bootloader:
```console
$ qemu-system-i386 -drive format=raw,file=proclamation.dat
```

![Alt text](imgs/qemu_start.png?raw=true "Starting the bootloader in qemu")

# analysis

We already know from the `strings` command that there are no ansi strings to look at in cleartext. This made me think that there is probably a decryption going-on since the text displayed in `qemu` is nowhere to be found.

Looking at the code, we can spot a loop around `0x7c1b`. From the `int 0x10` instruction, this looks like the loop where characters are displayed on the output. Let's check live...I started the bootloader in debug mode (`-S -s` added to `qemu` command line) and attached `gdb` to it:

```
(gdb) target remote localhost:1234
Remote debugging using localhost:1234
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
0x0000fff0 in ?? ()
(gdb) b *0x7c1b
Breakpoint 1 at 0x7c1b
(gdb) c
Continuing.

Breakpoint 1, 0x00007c1b in ?? ()
(gdb) x /10i $pc
=> 0x7c1b:	pop    %esi
   0x7c1c:	add    $0x14,%esi
   0x7c1f:	mov    $0x9,%dl
   0x7c21:	push   %dx
   0x7c23:	mov    $0x0,%bl
   0x7c25:	mov    $0xe,%ah
   0x7c27:	mov    (%ebx,%eax,4),%al
   0x7c2a:	movb   $0x66,(%ecx)
   0x7c2d:	pop    %edx
   0x7c2e:	shl    $0x2,%dx
```

Stepping through the execution, we can see the text being decrypted:
- decrypted data is stored at `0x7c78`
- `dx` is used as a `xor` key with an initial value of `0x9`
- the decryption loop stops when the result is `\x00`

Yet, there is still some data at the end... Might be worth trying to decrypt this as well...

# solution

We extract bytes from `0x7c78` till the end of the bootloader and map it as an array of bytes in `python` and reimplement the decryption steps:

```python
res = ""
key = 0x09
data = [0x2e, 0xbf, 0xc6, 0x86, 0x85, 0xc4, 0xca, 0xbd, 0x8f, 0xca, 0x8b, 0x98, 0x8f, 0xca, 0x86, 0x85, 0x85, 0x81, 0x83, 0x84, 0x8d, 0xca, 0x8c, 0x85, 0x98, 0xca, 0x82, 0x83, 0x8d, 0x82, 0x86, 0x93, 0xca, 0x83, 0x84, 0x9e, 0x8f, 0x86, 0x86, 0x83, 0x8d, 0x8f, 0x84, 0x9e, 0xe0, 0x83, 0x84, 0x8e, 0x83, 0x9c, 0x83, 0x8e, 0x9f, 0x8b, 0x86, 0x99, 0xc4, 0xca, 0xbe, 0x85, 0xca, 0x8c, 0x83, 0x84, 0x8e, 0xca, 0x9e, 0x82, 0x8f, 0x87, 0xc6, 0xca, 0x9d, 0x8f, 0xca, 0x82, 0x8b, 0x9c, 0x8f, 0xca, 0x8e, 0x8f, 0x9c, 0x83, 0x99, 0x8f, 0x8e, 0xe0, 0x8b, 0xca, 0x9e, 0x8f, 0x99, 0x9e, 0xc4, 0xe0, 0xe0, 0xbe, 0x82, 0x8f, 0x98, 0x8f, 0xca, 0x83, 0x99, 0xca, 0x8b, 0xca, 0x87, 0x8f, 0x99, 0x99, 0x8b, 0x8d, 0x8f, 0xca, 0x82, 0x83, 0x8e, 0x8e, 0x8f, 0x84, 0xca, 0x83, 0x84, 0xca, 0x9e, 0x82, 0x83, 0x99, 0xca, 0x88, 0x85, 0x85, 0x9e, 0x86, 0x85, 0x8b, 0x8e, 0x8f, 0x98, 0xc4, 0xe0, 0xe0, 0xac, 0x83, 0x84, 0x8e, 0xca, 0x83, 0x9e, 0xc6, 0xca, 0x8b, 0x84, 0x8e, 0xca, 0x83, 0x9e, 0xca, 0x9d, 0x83, 0x86, 0x86, 0xca, 0x86, 0x8f, 0x8b, 0x8e, 0xca, 0x93, 0x85, 0x9f, 0xca, 0x85, 0x84, 0xca, 0x9e, 0x82, 0x8f, 0xca, 0x98, 0x85, 0x8b, 0x8e, 0xca, 0x9e, 0x85, 0xe0, 0x8c, 0x83, 0x84, 0x8e, 0x83, 0x84, 0x8d, 0xca, 0x9f, 0x99, 0xc4, 0xca, 0xbd, 0x8f, 0xca, 0x86, 0x85, 0x85, 0x81, 0xca, 0x8c, 0x85, 0x98, 0x9d, 0x8b, 0x98, 0x8e, 0xca, 0x9e, 0x85, 0xca, 0x87, 0x8f, 0x8f, 0x9e, 0xca, 0x9e, 0x82, 0x8f, 0xe0, 0x8c, 0x8f, 0x9d, 0xca, 0x9e, 0x82, 0x8b, 0x9e, 0xca, 0x9d, 0x83, 0x86, 0x86, 0xca, 0x87, 0x8b, 0x81, 0x8f, 0xca, 0x83, 0x9e, 0xca, 0x8b, 0x86, 0x86, 0xca, 0x9e, 0x82, 0x8f, 0xca, 0x9d, 0x8b, 0x93, 0xca, 0x9e, 0x82, 0x98, 0x85, 0x9f, 0x8d, 0x82, 0xc4, 0xe0, 0xe0, 0xad, 0x85, 0x85, 0x8e, 0xca, 0x86, 0x9f, 0x89, 0x81, 0xc6, 0xca, 0x8b, 0x84, 0x8e, 0xca, 0x98, 0x8f, 0x87, 0x8f, 0x87, 0x88, 0x8f, 0x98, 0xd0, 0xe0, 0xca, 0xca, 0xca, 0xca, 0xbd, 0x8f, 0xca, 0x86, 0x85, 0x9c, 0x8f, 0xca, 0x99, 0x9a, 0x8b, 0x89, 0x8f, 0x99, 0xca, 0x87, 0x9f, 0x89, 0x82, 0xca, 0x87, 0x85, 0x98, 0x8f, 0xca, 0x9e, 0x82, 0x8b, 0x84, 0xca, 0x9e, 0x8b, 0x88, 0x99, 0xcb, 0xea, 0x81, 0x19, 0x11, 0xa9, 0xb9, 0x91, 0xda, 0x98, 0x8e, 0xd9, 0x98, 0xb5, 0xda, 0x8c, 0xb5, 0xda, 0x92, 0xd8, 0xda, 0xb5, 0x88, 0xda, 0xda, 0x9e, 0x86, 0xda, 0x8b, 0x8e, 0xd9, 0x98, 0x97, 0x97, 0xea, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0xf4, 0x55, 0xaa]

for d in data:
    r = key << 0x02
    r += 0x42
    r = r & 0xff
    key = r
    res += chr(d ^ key)
print(res)
```

Running this, we are provided with the flag:

```console
$ ./sol.py
CS{0rd3r_0f_0x20_b00tl0ad3r}
```
